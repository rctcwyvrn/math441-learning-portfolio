<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Math 441 portfolio</title>
    <link>https://rctcwyvrn.github.io/math441-learning-portfolio/</link>
    <description>Recent content on Math 441 portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://rctcwyvrn.github.io/math441-learning-portfolio/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Alternative nearest neighbours algorithms</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/alternative_nearest_neighbours/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/alternative_nearest_neighbours/</guid>
      <description>&lt;!DOCTYPE html&gt; alternative_nearest_neighbours The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/alternative_nearest_neighbours.ipynb
During class we discussed a basic idea of nearest neighbours: each step simply introduce the nearest neighbour as the next node in the path. I had an idea for an addition to the method that I&#39;m curious to see if they&#39;ll make a difference at all
Starting with the code from lecture
In&amp;nbsp;[105]: import numpy as np import scipy.</description>
    </item>
    
    <item>
      <title>Cover letter</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cover/</guid>
      <description>Intro Over the course of the term we got to learn about a number of optimization problems and saw how they could be solved using various libraries and techniques. While watching these problems get solved I often found myself wondering how things would go differently if some things were changed and that formed the basis of some of my learning portfolio entries. The rest of my learning portfolio entries are mainly focused on connecting problems we learned in class to other areas and seeing how these problems can be applied in different contexts.</description>
    </item>
    
    <item>
      <title>Deeper dive into optimal transport</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/optimal_transport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/optimal_transport/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/optimal_transport.md
A quick google search indicates that optimal transport is more than just a linear programming problem about moving resources, and has many far reaching applications
https://kantorovich.org/post/ot_intro/
This basic problem has a wealth of applications within mathematics (in the theory of partial differential equations, geometry, functional analysis, optimization, probability and so on) as well as in other fields (image processing, data science, economics, chemical physics etc.</description>
    </item>
    
    <item>
      <title>Exploring a smaller matrix representation of network flows</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/smaller_network_matrix_tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/smaller_network_matrix_tests/</guid>
      <description>&lt;!DOCTYPE html&gt; smaller_network_matrix_tests The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/smaller_network_matrix_tests.ipynb
In&amp;nbsp;[1]: import numpy as np import scipy.linalg as la # import pandas as pd import matplotlib.pyplot as plt from scipy.optimize import linprog import random def plotG(V,E,arrow_length=0.5,arrow_width=0.01,figsize=None): V = np.array(V); E = np.array(E) if figsize: plt.figure(figsize=figsize) for e in E: i,j = e plt.plot([V[i,0],V[j,0]],[V[i,1],V[j,1]],&amp;#39;k&amp;#39;) plt.arrow(V[i,0],V[i,1],(V[j,0] - V[i,0])*arrow_length,(V[j,1] - V[i,1])*arrow_length,width=arrow_width,color=&amp;#39;k&amp;#39;) plt.plot(V[:,0],V[:,1],&amp;#39;w.&amp;#39;,markersize=40,markeredgecolor=&amp;#39;k&amp;#39;) for i in range(V.shape[0]): plt.annotate(str(i),xy=V[i,:],ha=&amp;#39;center&amp;#39;,va=&amp;#39;center&amp;#39;) plt.axis(False) plt.show() During class we modelled network flows using a $ n^2-n $ sized matrix and naturally the question I had was, is it more efficient to just have a $ mxn $ sized matrix?</description>
    </item>
    
    <item>
      <title>Graph coloring and register allocation</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_and_register_allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_and_register_allocation/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_and_register_allocation.md
While implementing a compiler for CPSC 411 last year we had to implement a register allocator, which is a real world usage of graph coloring that I encountered last year. It has some interesting computational properties and it&amp;rsquo;s use of graph coloring is pretty interesting so I thought I could write about it for my learning portfolio. It turns out that for register allocation of real programs, the problem is so large that even a greedy approximation is too slow and an even faster algorithm is required!</description>
    </item>
    
    <item>
      <title>Graph coloring animations: Notes</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations_notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations_notes/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_animations_notes.md
These are notes on the greedy graph coloring algorithms that I animated using this script. A static version of the website generated by that script can be found here
So, why did I do this?
Well to be honest, because I was really curious. When we looked at networkx in lecture I saw that it provided support for a whole bunch of greedy algorithms and wanted to take a look at them.</description>
    </item>
    
    <item>
      <title>Graph coloring animations: Website</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations/</guid>
      <description> Intro This is a statically rendered version of the flask script that can be found at this link.
Since this website is static I&#39;m unable to render the proper version here, which is able to create new graphs with a given number of edges and nodes upon request
Notes on the what I discovered using these animations can be found here.
largest_first random_sequential smallest_last independent_set connected_sequential_bfs connected_sequential_dfs </description>
    </item>
    
    <item>
      <title>Knapsack problems, cryptography, and lattices</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cryptography_and_lattices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cryptography_and_lattices/</guid>
      <description>&lt;!DOCTYPE html&gt; cryptography_and_lattices The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/cryptography_and_lattices.ipynb
In 1976 Whitfield Diffie and Martin Hellman developed what would become a key concept in modern telecommunications, the public key cryptosystem. In a paper titled &#34;New directions in cryptography&#34; they developed the first public key exchange and theorized what would eventually become public key cryptography but with one key part missing. Diffie and Hellman built their model for a public key cryptosystem with a theoretical &#34;</description>
    </item>
    
    <item>
      <title>Solving mixed-integer linear programming</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/how_does_linprog_ip_work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/how_does_linprog_ip_work/</guid>
      <description>&lt;!DOCTYPE html&gt; how_does_linprog_ip_work The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/how_does_linprog_ip_work.ipynb
What&#39;s wrong with linprog?&amp;#182;During class when we want to solve integer programming problems we&#39;ve used the same scipy linprog solver that we used for linear programming, but just with the integrality parameter set. In class we&#39;ve claimed that this produces the &#34;optimal&#34; solution for these integer programming problems and we&#39;ve seen that integer programming is much more efficient than using a bruteforce combinatorial method.</description>
    </item>
    
  </channel>
</rss>
