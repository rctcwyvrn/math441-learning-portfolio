---
title: "Graph coloring animations: Notes"
---

The source code for this entry can be found at [https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_animations_notes.md](https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_animations_notes.md)


These are notes on the greedy graph coloring algorithms that I animated using [this script](https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_animations/graph_coloring_greedy_strategies.py). A static version of the website generated by that script can be found [here](/math441-learning-portfolio/post/graph_coloring_animations/)

# Why?

While looking at these graph coloring methods in classs I found that being able to see exactly the order that the greedy algorithms took nodes to color was helpful in understanding what exactly each algorithm was doing. So to help with this I made this animation generator, which is able to randomly generate graphs of a given size/edge count and perform different greedy algorithms side by side.

Using these animations I tried to figure out some intuition and reasoning behind each greedy algorithm.

# Observations

### Random sequential

> Returns a random permutation of the nodes of G as a list.

Quite straightforward, it does a greedy coloring in a completely random order. Why would we want to consider this? First of all, it provides a good baseline to compare algorithms against. If they can't outperform just randomly guessing a greedy order then they probably aren't worth considering. Another thing to consider is the worst case performance of different greedy algorithms, some of these algorithms might be very fast in some cases but very slow in other cases. By having a purely random algorithm we have something to compare against to see how good/bad the best/worst case performance is. 

### Smallest last
We covered "largest first" in class, but what does "smallest last" mean? Is it just a backwards version of largest first? 

> Returns a deque of the nodes of G, “smallest” last.
> Specifically, the degrees of each node are tracked in a bucket queue. From this, the node of minimum degree is repeatedly popped from the graph, updating its neighbors’ degrees.

Kinda but not really. The intuitive way of thinking about smallest last would be "order all the nodes by degree, put the smallest degree node last", but if you think about it this is identical to largest first so that wouldn't really do anything. Smallest last actually finds the smallest node and then removes it from the graph, before then finding the next smallest node and removing it from the graph and so on. After removing all the nodes, they're then colored in reverse of the order they were removed in.

So what does this accomplish? The intuition behind this method is that if you can color the graph with a node removed, then if the node you removed as few conflicts then you should be able to color the graph after you add that node back. So by removing the ones with the smaller number of conflicts first, it's more likely that they'll be colorable when it's their turn to be colored.

### Independent set 

> This algorithm repeatedly finds and removes a maximal independent set, assigning each node in the set an unused color.

First off what is an independent set? An independent set is a set of nodes in a graph that all share no edges with each other, so they're completely disconnected.

What does this greedy method do then? It finds as many nodes as possible that aren't connected and gives them all the same color. It then removes them all and repeats the process. We see this in the animations, while the other algorithms color one at a time with different colors we see that independent set colors a bunch of nodes one color, then another bunch of nodes another color and so on. Unlike the other greedy methods that return the order of iteration through the nodes, independent set has a very different way of coloring the nodes.

Intuitively this method makes a lot of sense, find as many nodes as possible that you can color with the same color and color them all. Then abandon that color entirely and continue. Since you never use that color again and you know the set is an independent set, you don't need to worry about any conflicts occuring.

### Connected sequential DFS and BFS

Both of these algorithms are based on the same idea

> Returns an iterable over nodes in G in the order given by a breadth-first or depth-first traversal.

Since a greedy graph coloring algorithm is just a choice of the order that we walk through the nodes, these two are pretty intuitive methods. While they might not have any special characteristics that make them good for graph coloring, much like random sequential they probably provide a good baseline to compare other greedy algorithms against. 