<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Math 441 portfolio</title>
    <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/</link>
    <description>Recent content in Posts on Math 441 portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://rctcwyvrn.github.io/math441-learning-portfolio/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A deep dive into optimal transport</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/optimal_transport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/optimal_transport/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/optimal_transport.md
A quick google search indicates that optimal transport is more than just a linear programming problem about moving resources, and has many far reaching applications
This basic problem has a wealth of applications within mathematics (in the theory of partial differential equations, geometry, functional analysis, optimization, probability and so on) as well as in other fields (image processing, data science, economics, chemical physics etc.</description>
    </item>
    
    <item>
      <title>Alternative nearest neighbours algorithms</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/alternative_nearest_neighbours/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/alternative_nearest_neighbours/</guid>
      <description>&lt;!DOCTYPE html&gt; alternative_nearest_neighbours The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/alternative_nearest_neighbours.ipynb
During class we discussed a basic idea of nearest neighbours: each step simply introduce the nearest neighbour as the next node in the path. I had an idea for an addition to the method that I&#39;m curious to see if they&#39;ll make a difference at all
Starting with the code from lecture
In&amp;nbsp;[105]: import numpy as np import scipy.</description>
    </item>
    
    <item>
      <title>Cover letter</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cover/</guid>
      <description>Intro Over the course of the term we got to learn about a number of optimization problems and saw how they could be solved using various libraries and techniques. While watching these problems get solved I often found myself wondering how things would go differently if some things were changed and that formed the basis of some of my learning portfolio entries. The rest of my learning portfolio entries are mainly focused on connecting problems we learned in class to other areas and seeing how these problems can be applied in different contexts.</description>
    </item>
    
    <item>
      <title>Exploring a smaller matrix representation of network flows</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/smaller_network_matrix_tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/smaller_network_matrix_tests/</guid>
      <description>&lt;!DOCTYPE html&gt; smaller_network_matrix_tests The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/smaller_network_matrix_tests.ipynb
During class we modelled network flows using a $ n^2-n $ sized matrix and naturally the question I had was, is it more efficient to just have a $ mxn $ sized matrix?
Recall that during lecture we did our optimization with a $n^2 - n$ sized vector $x$ which was a flattened representation of $x$ as a matrix where each $x_{i,j}$ represented the flow between nodes $i$ and $j$.</description>
    </item>
    
    <item>
      <title>Graph coloring and register allocation</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_and_register_allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_and_register_allocation/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_and_register_allocation.md
While implementing a compiler for CPSC 411 last year we had to implement a register allocator, which is a real world usage of graph coloring. It has some cool computational properties and it&amp;rsquo;s use of graph coloring is pretty interesting so I thought I would write about it for my learning portfolio. It turns out that for register allocation of real programs, the problem is so large that even a greedy approximation is too slow and an even faster algorithm is required!</description>
    </item>
    
    <item>
      <title>Greedy graph coloring animations and intuitions</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/graph_coloring_animations/</guid>
      <description>The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/graph_coloring_animations_notes.md
Intro This is a statically rendered version of the flask script that can be found at this link.
Since this website is static I&#39;m unable to render the proper version here, which is able to create new graphs with a given number of edges and nodes upon request
Why? While looking at these graph coloring methods in classs I found that being able to see exactly the order that the greedy algorithms took nodes to color was helpful in understanding what exactly each algorithm was doing.</description>
    </item>
    
    <item>
      <title>Knapsack problems, cryptography, and lattices</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cryptography_and_lattices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/cryptography_and_lattices/</guid>
      <description>&lt;!DOCTYPE html&gt; cryptography_and_lattices The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/cryptography_and_lattices.ipynb
In 1976 Whitfield Diffie and Martin Hellman developed what would become a key concept in modern telecommunications, the public key cryptosystem. In a paper titled &#34;New directions in cryptography&#34; [1] they developed the first public key exchange and theorized what would eventually become public key cryptography but with one key part missing. Diffie and Hellman built their model for a public key cryptosystem with a theoretical &#34;</description>
    </item>
    
    <item>
      <title>Solving mixed-integer linear programming problems</title>
      <link>https://rctcwyvrn.github.io/math441-learning-portfolio/post/how_does_linprog_ip_work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rctcwyvrn.github.io/math441-learning-portfolio/post/how_does_linprog_ip_work/</guid>
      <description>&lt;!DOCTYPE html&gt; how_does_linprog_ip_work The source code for this entry can be found at https://github.com/rctcwyvrn/math441-learning-portfolio/blob/master/how_does_linprog_ip_work.ipynb
Over the course of the term I had a nagging thought in the back of my mind with the usage of linprog and using it to solve integer programming problems arising from NP-hard problems.
What&#39;s wrong with linprog?&amp;#182;During class when we want to solve integer programming problems we&#39;ve used the same scipy linprog solver that we used for linear programming, but just with the integrality parameter set.</description>
    </item>
    
  </channel>
</rss>
